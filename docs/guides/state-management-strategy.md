---
title: 상태 관리 전략 가이드
audience: human
scope: frontend
tags: [state, onboarding]
version: 1.0.0
updated: 2025-09-18
---

# 상태 관리 전략 가이드

> 대상: 프로젝트에 처음 합류한 프론트엔드 개발자. 이 문서는 “어떤 데이터는 어디에 저장해야 하는지”를 직관적으로 설명합니다. 코드 대신 판단 기준에 집중합니다.

## 1. 먼저 구분하기: 데이터는 두 종류

- **서버 상태(Server State)**: 백엔드에서 가져오는 데이터. 언제든지 서버와 동기화가 필요합니다. 예) 상품 목록, 사용자 정보, 통계.
- **클라이언트 상태(Client State)**: 화면에만 필요한 값. 서버와 직접 연결되지 않습니다. 예) 현재 열려 있는 모달, 선택된 탭, 다크모드 여부.

포인트는 “이 값이 서버에서 최신값을 가져와야 하는가?”입니다. 그렇다면 서버 상태, 아니라면 클라이언트 상태입니다.

## 2. 어떤 도구를 쓸까?

| 상황                                  | 권장 도구                   | 이유                                                      |
| ------------------------------------- | --------------------------- | --------------------------------------------------------- |
| 서버에서 받아온 데이터 목록/디테일    | **TanStack Query**          | 자동 캐싱, 최신 상태 동기화, 로딩/에러 관리 기본 제공     |
| 앱 전체에서 공유하는 사용자 설정      | **Zustand**                 | 가볍고 단순한 글로벌 스토어. 서버 동기화는 직접 하지 않음 |
| 특정 컴포넌트 내부에서만 쓰는 임시 값 | **React State(useState)**   | 가장 단순하고 빠름. 부모~자식 간 전달에만 사용            |
| 폼 입력과 검증                        | **React Hook Form (+ Zod)** | 폼 전용. 입력값 추적, 에러 메시지, 제출 처리까지 담당     |

결정 포인트를 고민할 때는 “다른 페이지에서도 필요할까?”, “새로고침하면 서버에서 다시 받아야 할까?”를 동시에 생각하면 쉽게 도구를 고를 수 있습니다.

## 3. TanStack Query를 선택하는 순간

다음 중 하나라도 해당하면 Query를 선택합니다.

- 백엔드 API에서 데이터를 가져온다.
- 같은 데이터를 여러 컴포넌트에서 사용한다.
- 쓰기(생성/수정/삭제) 후 목록/상세를 최신 상태로 재검증하고 싶다.

TanStack Query는 “데이터를 기억하고, 새로고침”하는 비서처럼 동작합니다. 자동으로 로딩/에러를 알려주고 캐시된 데이터를 재사용하기 때문에 서버 통신을 줄여줍니다.

주의할 점은 “서버에서 받아온 데이터를 Query 외 다른 곳(Zustand 등)에 복사하지 않는다”는 것입니다. 복사하면 두 곳을 모두 관리해야 하므로 싱크가 엇나가기 쉽습니다.

## 4. Zustand를 선택하는 순간

이 조건을 모두 충족할 때만 Zustand를 씁니다.

1. 서버와 직접 동기화할 필요가 없다.
2. 여러 컴포넌트에서 동일한 값을 사용한다.
3. 브라우저에서만 의미가 있다.

대표 예시는 **사용자 인증 상태**, **테마**, **최근 사용한 필터**처럼 앱 전역에서 참고하지만 서버에서 즉시 확인하지 않아도 되는 값들입니다. Zustand는 단순한 key-value 저장소로 생각하면 편합니다.

주의할 점은 상태가 커지면 구조를 모듈로 나누고, 불필요한 렌더링이 일어나지 않도록 selector를 사용해야 한다는 것입니다. 다만 초심자라면 “Zustand에는 진짜 전역 설정만 둔다”는 원칙만 기억해도 충분합니다.

## 5. React State만으로 충분한 순간

컴포넌트 안에서만 쓰고 밖에서 알 필요가 없다면 `useState` 하나면 충분합니다. 예를 들어 탭 전환, 토글 버튼, 폼 안의 임시 상태 등입니다.

주의할 점은 이 로컬 상태가 다른 곳에서도 필요한 순간이 생기면 **즉시 TanStack Query 또는 Zustand로 옮길지 검토**해야 한다는 것입니다. “잠깐 props로 넘겨주면 되겠지”라는 생각으로 상태를 끌고 다니다 보면 유지보수가 어려워집니다.

## 6. React Hook Form을 쓰는 순간

폼은 처리할 일이 많습니다.

- 입력값 저장
- 필드별 에러 확인
- 제출 시 서버로 전송

React Hook Form은 이 과정을 간단히 해 주는 폼 전용 도구입니다. Zod와 함께 쓰면 입력값 검증도 한 번에 해결됩니다. 폼을 React State나 Zustand로 직접 관리하면 중복되는 코드를 많이 작성해야 하므로, 폼이라면 그냥 Hook Form을 선택하는 것이 시간을 아낍니다.

## 7. 흔한 실수와 대처법

- **서버 데이터를 Zustand에 저장**: Query로 가져온 내용을 다른 스토어에 복사하지 않습니다. 캐시가 두 개가 되고, 하나는 반드시 낡은 값이 됩니다.
- **조금 특이한 케이스라서“ useState”로 일단 처리**: 나중에 유지보수가 안 됩니다. “이 상태는 누구 몫인가?”를 지금 명확히 결정하세요.
- **폼을 직접 구현**: 초반에는 편하지만, 에러 처리와 제출 후 초기화까지 고려하면 Hook Form이 훨씬 단순합니다.
- **조건부로 도구 섞기**: 같은 데이터 흐름에 두 가지 도구를 섞어 쓰면 이해하기 어려워집니다. 데이터 종류마다 도구 하나만 선택합니다.

## 8. 어떻게 점검할까?

새로운 기능을 만들 때 아래 질문을 점검표처럼 활용하세요.

1. **이 데이터는 서버와 동기화가 필요한가?** → 네: TanStack Query / 아니오: 클라이언트 상태.
2. **여러 컴포넌트에서 동시에 필요한가?** → 네: Zustand 검토 / 아니오: React State로 충분.
3. **입력 폼인가?** → 네: React Hook Form.
4. **서버 응답을 검증하고 있는가?** → 네: Zod 스키마 사용 / 아니오: 스키마 추가 고려.

## 9. 더 배우고 싶다면

- 상태 관리 제약 요약: [`AGENTS.md`](../../AGENTS.md#state_management_constraints)
- Next.js 컴포넌트 패턴과 상태 예시: [`docs/conventions/patterns.md`](../conventions/patterns.md)
- DTO ↔ Entity 변환 가이드: [`docs/guides/entity-dto-model-guide.md`](./entity-dto-model-guide.md)
- 테스트 전략에서 상태 흐름 검증하기: [`docs/guides/testing-guide.md`](./testing-guide.md)

---

### 핵심 요약

- 서버와 동기화가 필요한 값은 TanStack Query, 전역 UI 설정은 Zustand, 컴포넌트 내부 임시는 React State, 폼은 React Hook Form.
- 동일한 데이터를 두 곳 이상에 복사하지 않는다.
- 상태 종류를 먼저 분류하고, 도구는 그다음에 고른다.
- 위 질문표를 개발 전 체크하면 큰 시행착오를 줄일 수 있다.
